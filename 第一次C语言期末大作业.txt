#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <time.h>
#include <windows.h>
#define path "C:\\Users\\86191\\Desktop\\2048.txt"
struct players
//创建链表
{
    int num;
    char name[20];
    int bushu;
    struct players *next;
};
int map[4][4] = {0};
//4*4的二维0数组
int i,j;
//全局变量，使代码简洁
void print()
//打印图像
{
    printf("上：w;");
    printf("下：s;");
    printf("左:a;");
    printf("右：d;");
    printf("退出:q\n");
    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 4; j++)
        {
            printf("%d\t", map[i][j]);
        }
        printf("\n");
    }
}
//moveRigt第一部分是从最右边往左数如果相同就做加法运算
//第二部分是如果左右2个数字中间空着0，就将左边的数移动到右边去
int moveRight()
{
    int flag = 0;
    //来标记是否整个map矩阵能否改变，以此判断整个游戏是否结束
    //这个循环的目的是为了做某一行的加减,如某一行为[2 2 8 8]，经过以下运算就会变为[0 4 0 16];
    for (i = 0; i < 4; i++)
    {
        for (j = 4 - 1; j >= 0; j--)
        {
            int cell = map[i][j];
            if (cell != 0)
            {
                int k = j - 1;
                while (k >= 0)
                {
                    int nextcell = map[i][k];
                    if (nextcell != 0)
                    {
                        if (cell == nextcell)
                        {
                            flag = 1;
                            map[i][j] += map[i][k];
                            map[i][k] = 0;
                        }
                        k = -1;
                        break;
                    }
                    k--;
                }
            }
        }
    }
    //上一步做的是数据加减，这一步对加减后的数据做数据处理
    //例如某一行经过上一步的数据为【0 4 0 16】，将会变为【0 0 4 16】
    for (i = 0; i < 4; i++)
    {
        for (j = 4 - 1; j > 0; j--)
        {
            int cell = map[i][j];
            if (cell == 0)
            {
                int k = j - 1;
                while (k >= 0)
                {
                    int nextcell = map[i][k];
                    if (nextcell != 0)
                    {
                        flag = 1;
                        //当前元素为0，说明能移动，改变flag的值
                        map[i][j] = nextcell;
                        map[i][k] = 0;
                        k = -1;
                    }
                    k--;
                }
            }
        }
    }
    //判断标志变量，并输出0或-1
    if (flag)
        return 0;
    else
    {
        return -1;
    }
}
//moveLeft第一部分是从最左边往右数如果相同就做加法运算
//第二部分是如果左右2个数字中间空着0，就将右边的数移动到左边去
int moveLeft()
{
    int flag = 0;
    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 4; j++)
        {
            int cell = map[i][j];
            //cell单词用的不太恰当，表示当前元素，你可以采用更有意义的命名
            if (cell != 0)
            {
                int k = j + 1;
                while (k < 4)
                {
                    int nextcell = map[i][k];
                    if (nextcell != 0)
                    {
                        if (cell == nextcell)
                        {
                            flag = 1;
                            //相邻两个元素相同，就说明能移动，所以改变flag的值
                            map[i][j] += map[i][k];
                            map[i][k] = 0;
                        }
                        k = 4;
                        break;
                    }
                    k++;
                }
            }
        }
    }
    //修改部分：for循环中的i或者j的循环条件
    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 4 - 1; j++)
        {
            int cell = map[i][j];
            if (cell == 0)
            {
                int k = j + 1;
                while (k < 4)
                {
                    int nextcell = map[i][k];
                    if (nextcell != 0)
                    {
                        flag = 1;
                        map[i][j] = nextcell;
                        map[i][k] = 0;
                        k = 4;
                    }
                    k++;
                }
            }
        }
    }
    //判断标志变量，并输出0或-1
    if (flag)
        return 0;
    else
    {
        return -1;
    }
}
//moveDown第一部分是从最下边往上数如果相同就做加法运算
//第二部分是如果上下2个数字中间空着0，就将上边的数移动到下边去
int moveDown()
{
    int flag = 0;
    for (i = 4 - 1; i >= 0; i--)
    {
        for (j = 0; j < 4; j++)
        {
            int cell = map[i][j];
            if (cell != 0)
            {
                int k = i - 1;
                while (k >= 0)
                {
                    int nextcell = map[k][j];
                    if (nextcell != 0)
                    {
                        if (map[i][j] == map[k][j])
                        {
                            flag = 1;
                            map[i][j] += map[k][j];
                            map[k][j] = 0;
                        }
                        k = 0;
                        break;
                    }
                    k--;
                }
            }
        }
    }
    //修改部分：for循环中的i或者j的循环条件
    for (i = 4 - 1; i > 0; i--)
    {
        for (j = 0; j < 4; j++)
        {
            int cell = map[i][j];
            if (cell == 0)
            {
                int k = i - 1;
                while (k >= 0)
                {
                    int nextcell = map[k][j];
                    if (nextcell != 0)
                    {
                        flag = 1;
                        map[i][j] = nextcell;
                        map[k][j] = 0;
                        k = 0;
                    }
                    k--;
                }
            }
        }
    }
    //判断标志变量，并输出0或-1
    if (flag)
        return 0;
    else
    {
        return -1; //游戏结束
    }
}
//moveUp第一部分是从最上边往下数如果相同就做加法运算
//第二部分是如果上下2个数字中间空着0，就将下边的数移动到上边去
int moveUp()
{
    int flag = 0;
    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 4; j++)
        {
            int cell = map[i][j];
            if (cell != 0)
            {
                int k = i + 1;
                while (k < 4)
                {
                    int nextcell = map[k][j];
                    if (nextcell != 0)
                    {
                        if (cell == nextcell)
                        {
                            flag = 1;
                            map[i][j] += map[k][j];
                            map[k][j] = 0;
                        }
                        k = 4;
                        break;
                    }
                    k++;
                }
            }
        }
    }
    //修改部分：for循环中的i或者j的循环条件
    for (i = 0; i < 4 - 1; i++)
    {
        for (j = 0; j < 4; j++)
        {
            int cell = map[i][j];
            if (cell == 0)
            {
                int k = i + 1;
                while (k < 4)
                {
                    int nextcell = map[k][j];
                    if (nextcell != 0)
                    {
                        flag = 1;
                        map[i][j] = nextcell;
                        map[k][j] = 0;
                        k = 4;
                    }
                    k++;
                }
            }
        }
    }
    //判断标志变量，并输出0或-1
    if (flag)
        return 0;
    else
    {
        return -1;
    }
}
//判断最大数是否为2048，若是则结束游戏
int big_num()
{
    for(i=0; i<4; i++)
    {
        for(j=0; j<4; j++)
        {
            if(map[i][j]==2048)
            {
                return -1;
            }
        }
    }
    return 0;
}
//判断游戏是否结束
//原理：如果四个移动函数都返回-1即不能移动GameOver，则返回1，结束main中循环
int gameOver(int board[4][4])
{
    int copy_board[4][4],i,j;
    /*为了避免直接把board[][]传进move函数判断的时候改变board，所以把board复制给
    另一个数组,然后判断，这样就不会改变board数组了
    */
    for(i=0; i<4; i++)
    {
        for(j=0; j<4; j++)
        {
            copy_board[i][j]=board[i][j];
        }
    }
    if((moveDown(copy_board)==-1&&moveUp(copy_board)==-1&&moveLeft(copy_board)==-1&&moveRight(copy_board)==-1)||big_num()==-1)
        return 1;
    else
        return 0;

}
//生成随机数
//原理：先用一个条件语句遍历4*4的数组是否有0，然后再随机在map{i}{j}=0处添加0，2或4
int randInteger()
{
    srand((unsigned)time(NULL));
    int n = 0, m =0, i, j;
    for(i=0; i<4; i++)
    {
        for(j=0; j<4; j++)
        {
            if(map[i][j]==0)
            {
                m++;
            }
        }
    }
    if(m>0)
    {
        do
        {
            i = rand()%5;//0-4
            j = rand()%5;
            n++;
        }
        while(map[i][j] != 0 || n == 10000);
    }
    if (map[i][j] == 0)
    {
        do
        {
            map[i][j] = 2 + rand()%3;//2-4
        }
        while(map[i][j]==3);//排除3
        return 0;
    }
    return 0;
}
//重置map，另数组中每个数都为0
void reset()
{
    for(i=0; i<4; i++)
    {
        for(j=0; j<4; j++)
        {
            map[i][j] = 0;
        }
    }
}
struct players *create_players(int num)
//用结构体函数创建玩家
{
    struct players *p;
    p=malloc(sizeof(struct players));
    printf("请输入玩家的名字:");
    scanf("%s",p->name);
    p->num=num;
    printf("猜测该玩家步数为:");
    scanf("%d",&p->bushu);
    return p;
}
void updata_players(struct players *head)
//将用掉的步骤添加到链表之中
{
    struct players *p2=NULL;
    int n;
    p2=head->next;
    if(p2==NULL)
        //若无人登榜
    {
        printf("还没有玩家登榜哦!\n");
        return;
    }
    printf("这是第几号玩家？");
    scanf("%d",&n);
    printf("请为%d号玩家填上步骤",n);
    while(p2)
    {
        if(p2->num==n)
            scanf("%d",&p2->bushu);
        p2=p2->next;
    }
}
void add_players(struct players *head)
//增加玩家的信息
{
    //排序插入
    struct players *p1=NULL,*p2=NULL;
    int num;
    printf("请输入玩家的序号:");
    p2=head->next;
    scanf("%d",&num);
    //char name[10];
    if(num>0)
    {
        if(p2==NULL)
        {
            p1=create_players(num);
            p1->next=NULL;
            head->next=p1;
            printf("序号为:%d的玩家添加成功!\n祝你游戏愉快\n",num);
            return;
        }
        while(p2)
        {
            if(p2->num==num)
            {
                printf("该序号已经有玩家!\n");
                //避免序号重复
                return;
            }
            if(p2->next==NULL)//插入尾部
            {
                p1=create_players(num);
                p1->next=NULL;
                p2->next=p1;
                printf("玩家:%d添加成功!\n祝你游戏愉快",num);
                return;
            }
            p2=p2->next;
        }
    }
    else
    {
        printf("请输入规范的序号");
        return;
    }
}
struct players *new_data()
//将新数据进行动态内存分配
{
    struct players *p=NULL;
    p=(struct players *)malloc(sizeof(struct players));
    return p;
}
void read_data(struct players *head)
//读取文件
{
    FILE *fp;
    struct players *p=NULL,*q=NULL;
    p=head;
    fp=fopen(path,"r");
    q=new_data();
    while(fread(q,sizeof(struct players),1,fp)==1)
    {
        p->next=q;
        p=p->next;
        q=new_data();
    }
    fclose(fp);
}
void look_players(struct players *head)
//游戏结束后查看所有玩家信息并打印
{
    struct players *p1;
    p1=head->next;
    if(p1==NULL)
    {
        printf("榜单没有该玩家信息!\n");
        return;
    }
    printf("游戏结束！揭榜时刻来临~");
    printf("\n*序号*\t*姓名*\t*步骤*\n");
    printf("******************************\n");
    do
    {
        printf("%d\t%s\t%d\n",p1->num,p1->name,p1->bushu);
        p1=p1->next;
    }
    while(p1);
    printf("******************************\n");
}
void wirte_data(struct players *head)
//存储玩家榜单到文件中
{
    struct players *p=NULL;
    FILE *fp;
    fp=fopen(path,"w");
    p=head->next;
    while(p)
    {
        fwrite(p,sizeof(struct players),1,fp);
        p=p->next;
    }
    fclose(fp);
}
int main()
//主体
{
    printf("假设你是2048的游戏测试师\n");
    printf("现在要求你用这个游戏找不同玩家测试Bug\n");
    printf("并自己猜测该玩家能走多少步\n");
    int x[10];
    //不超过十个玩家，包含所有玩家的步骤
    int n, m;
    struct players *head =NULL;
    head=malloc(sizeof(struct players));
    head->next=NULL;
    char key;
    printf("请输入玩家个数(不超过10个):");
    scanf("%d",&n);
    for(m=0; m<n; m++)
    {
        x[m]=0;//初始化步骤为0
    }
    for(m=0; m<n; m++)
    {
        //清屏上次玩家图案，输出提示
        if(m>0)
        {
            system("cls");
            printf("上次游戏已经结束,有请下一位选手。\n");
        }
        read_data(head);
        add_players(head);
        randInteger();//先生成随机数
        Sleep(200);//延时200ms
        print();//显示图像
        while (gameOver(map)==0)//判断游戏是否结束
        {
            key = getch();//不显示用户输入
            switch (key)
            {
            case 'w'://上移
            {
                system("cls");
                moveUp();
                randInteger();//2048在移动后生成随机数
                Sleep(5);
                print();
                x[m]++;
                break;
            }
            case 's'://下移
            {
                system("cls");
                moveDown();
                randInteger();
                Sleep(5);
                print();
                x[m]++;
                break;
            }
            case 'a'://左移
            {
                system("cls");
                moveLeft();
                randInteger();
                Sleep(5);
                print();
                x[m]++;
                break;
            }
            case 'd'://右移
            {
                system("cls");
                moveRight();
                randInteger();
                Sleep(5);
                print();
                x[m]++;
                break;
            }
            case 'q'://主动退出
                return 0;
            }
        }
        printf("该玩家最终步骤为:%d\n",x[m]);
        printf("请你填写:");
        updata_players(head);
        wirte_data(head);
        reset();//重置map
    }
    look_players(head);
    return 0;
}
